class ReservationTest is subclass of Test
operations
	public createReservation: User * Accomodation * Types`DateTime * Types`DateTime ==> Reservation
	createReservation(u, a, cI, cO) ==
		return new Reservation(u, a, cI, cO) ;
	
	public testCreateReservation: () ==> ()
	testCreateReservation() == (
		dcl price: real := 120;
		dcl userWallet: real := 50000;
		dcl hostWallet: real := 0;
		dcl cI: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,19), mk_Types`Time(14, 00, 00));
		dcl cO: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,30), mk_Types`Time(11, 00, 00));
		dcl u: User := new User("Antonio","Antonio Melo", "antonio@gmail.com", "12345", "Portugal", "911111111", "Empresa", 123, 123, userWallet);
		dcl l: Landlord := new Landlord("Bruno","Bruno Santos",<Male>,"922222222", "bruno@gmail.com","1234",<English>, "Rua das Flores", "Porto","4400-458","Portugal", "www.casas.com", <Owner>, hostWallet);
		dcl a : Accomodation := new Accomodation("Porto",2,4,2,1,l,<House>, price);
		dcl r : Reservation := createReservation(u,a,cI,cO);
		assert(r.getAccomodation() = a);
		assert(r.getCheckIn() = cI);
		assert(r.getCheckOut() = cO);
		assert(r.getPrice() = price);
		assert(r in set a.getReservations());
		assert(r.getUser().getWallet() = userWallet-price);
		assert(r.getAccomodation().getHost().getWallet() = hostWallet+price);
	);
	
	public testOverlappingReservations: () ==> ()
	testOverlappingReservations() == (
		dcl price: real := 120;
		dcl userWallet: real := 50000;
		dcl hostWallet: real := 0;
		dcl u: User := new User("Antonio","Antonio Melo", "antonio@gmail.com", "12345", "Portugal", "911111111", "Empresa", 123, 123, userWallet);
		dcl l: Landlord := new Landlord("Bruno","Bruno Santos",<Male>,"922222222", "bruno@gmail.com","1234",<English>, "Rua das Flores", "Porto","4400-458","Portugal", "www.casas.com", <Owner>, hostWallet);
		dcl a : Accomodation := new Accomodation("Porto",2,4,2,1,l,<House>, price);
		
		dcl cI1: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,19), mk_Types`Time(14, 00, 00));
		dcl cO1: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,30), mk_Types`Time(11, 00, 00));
		dcl r1 : Reservation := createReservation(u,a,cI1,cO1);
		
		dcl cI2: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,8), mk_Types`Time(14, 00, 00));
		dcl cO2: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,19), mk_Types`Time(11, 00, 00));
		dcl r2 : Reservation := createReservation(u,a,cI2,cO2);
		
		dcl cI3: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2017,10,6), mk_Types`Time(14, 00, 00));
		dcl cO3: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2017,11,5), mk_Types`Time(11, 00, 00));
		dcl r3 : Reservation := createReservation(u,a,cI3,cO3);
		
		dcl cI4: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2017,12,26), mk_Types`Time(14, 00, 00));
		dcl cO4: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,4), mk_Types`Time(11, 00, 00));
		dcl r4 : Reservation := createReservation(u,a,cI4,cO4);
		
		dcl cI5: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,3,4), mk_Types`Time(14, 00, 00));
		dcl cO5: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,3,9), mk_Types`Time(11, 00, 00));
		dcl r5 : Reservation := createReservation(u,a,cI5,cO5);
		
		dcl cI6: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,3), mk_Types`Time(14, 00, 00));
		dcl cO6: Types`DateTime := mk_Types`DateTime(mk_Types`Date(2018,1,8), mk_Types`Time(11, 00, 00));
		dcl r6 : Reservation;
		
		a.cancelReservation(r4);
		r6 := createReservation(u,a,cI6,cO6);
		
		assert(r1 in set a.getReservations());		
		assert(r2 in set a.getReservations());
		assert(r3 in set a.getReservations());
		assert(r4 not in set a.getReservations());
		assert(r5 in set a.getReservations());
		assert(r6 in set a.getReservations());
		
		assert(r1.getUser().getWallet() = userWallet-price*5);
		assert(r1.getAccomodation().getHost().getWallet() = hostWallet+price*5);
	);
	
	public test: () ==> ()
	test() == (
		testCreateReservation();
		testOverlappingReservations();
	);
end ReservationTest