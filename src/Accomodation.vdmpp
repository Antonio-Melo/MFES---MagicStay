class Accomodation
types
-- TODO Define types here
	public TypeOf = <House> | <Apartment> | <ApartaHotel> | <Hotel>;
values
-- TODO Define values here
instance variables
-- TODO Define instance variables here
	area: seq of char;
	numBedrooms: nat;
	numStars: nat;
	numBeds: nat;
	numOfBathrooms: nat;
	host: Landlord;
	type: TypeOf;
	price: real;
	
	reservations: set of Reservation := {};
	reviews: set of Review := {};
operations
	-- TODO Define operations here
	public Accomodation(a: seq of char, nBedrooms: nat, nStars: nat, nBeds: nat, nBathrooms: nat, user: Landlord, typeOf: TypeOf, p: real) ret: Accomodation == (
		area := a;
		numBedrooms := nBedrooms;
		numStars := nStars;
		numBeds := nBeds;
		numOfBathrooms := nBathrooms;
		host := user;
		type := typeOf;
		price := p;
		host.addHouse(self);
	)
	post ret.area = a and
			 ret.numBedrooms = nBedrooms and
			 ret.numStars = nStars and
			 ret.numBeds = nBeds and
			 ret.numOfBathrooms = nBathrooms and
			 ret.host = user and
			 ret.type = typeOf and
			 ret.price = p and
			 ret in set ret.host.getHouses(); 
	
	public getArea() ret: seq of char ==
		return area;
		
	public getNumBedrooms() ret: nat ==
		return numBedrooms;
		
	public getNumStars() ret: nat ==
		return numStars;
		
	public getNumBeds() ret: nat ==
		return numBeds;
	
	public getNumOfBathrooms() ret: nat ==
		return numOfBathrooms;
	
	public getHost() ret: Landlord == 
		return host;
	
	public getType() ret: TypeOf ==
		return type;
	
	public getPrice() ret: real ==
		return price;
		
	pure public getReservations() ret: set of Reservation == (
		return reservations;
	);
	
	public addReview(rev: Review) == (
		reviews := reviews union {rev};
	) pre rev not in set reviews;
	
	public removeReview(rev: Review) == (
		reviews := reviews \ {rev};
	)pre rev in set reviews;
	
	public getReviews() ret: set of Review== 
		return reviews;
	
	public addReservation(res: Reservation) == (
		for all reservation in set reservations do (
			if overlaps(res, reservation) then
				return;
		);
		res.setPrice(price);
		res.getUser().transaction(-price);
		host.transaction(price);
		reservations := reservations union {res};
	)
	pre res.getUser().getWallet() > price;

	private overlaps(res1: Reservation, res2: Reservation) ret: bool == (
		if Types`compare(res1.getCheckIn().date, res2.getCheckOut().date) <= 0 or Types`compare(res2.getCheckIn().date, res1.getCheckOut().date) <= 0 then (
			return false)
		else
			return true;
	);


functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Accomodation